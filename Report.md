# Subject
Kernel to SMM local privilege escalation in UX360CA BIOS version 303

# Issue Description

## Summary

UX360CA BIOS version 303 has 3 vulnerabilities that allow an attacker with the ring0 privilege to overwrite nearly arbitrary physical memory including SMRAM and execute arbitrary code in SMM.

## Vulnerabilities

The vulnerable modules and corresponding SMIs are: UsbRt (0x31), SdioSmm (0x40), and NvmeSmm (0x42). All of those SMI handlers read physical memory address 0x40E to get an address to work on and write one byte to the address in case of error, even if it is SMRAM.

For example, SdioSmm's SMI handler looks as follows:
```cpp
__int64 SdioSmm_SwSmi_40h()
{
  struct_v0 *userControlled; // rbx

  byte_88702F60 = 1;
  userControlled = *(0x10 * MEMORY[0x40E] + 0x104);
  if ( (CheckMemoryRange(userControlled, 0x67i64) & 0x8000000000000000ui64) != 0i64
    || userControlled->ComandNo >= 4u )
  {
    userControlled->byte2 = 7;
  }
  else
  {
    (off_88701818[userControlled->ComandNo])(userControlled);
  }
  return 0i64;
}
```

This issue appears to be identical with INTEL-SA-00057, which is greatly described as [Aptiocalypsis](https://github.com/Cr4sh/Aptiocalypsis). The latest BIOS for UX360CA (version 303), however, does not include updates remaining to be vulnerable.

## Exploitation

This allows an attacker with write access to physical memory and the OUT instruction (ie, the ring0 privileges) to overwrite contents of SMRAM with the following steps:
1. Make sure physical address 0x40e is zero (which is most likely the case already)
2. Write an address of SMRAM, say 0x88400000, at physical address 0x104
3. Issue the SMI 0x40
4. 0x88400000+2 is updated with 0x7.

This can be used to achieve arbitrary code execution in SMM as follows:
1. Find the address of the System Management Service Table (SMST) in SMRAM, the below steps:
    1. Get runtime code physical memory range(s) from the contents of the `.Raw` value in `HKLM\HARDWARE\RESOURCEMAP\System Resources\Loader Reserved`
    2. Find the address of SMM_CORE_PRIVATE_DATA by scanning the 'smmc' signature from the runtime code memory.
    3. SMM_CORE_PRIVATE_DATA has the pointer to the SMST at offset 30h
2. Overwrite the pointer to the SmmLocateProtocol function at offset d0h of the SMST using the above write primitive. The value is updated to 0x07070707.
3. Write shellcode at physical memory 0x07070707
4. Trigger another SMI that calls the Smst->SmmLocateProtocol, such as SMI 0xdf. The shellcode at 0x07070707 is executed in SMM.

Arbitrary code execution in SMM would let an attacker bypass security measures by kernel and hypervisor such as HVCI as demonstrated in [another SMM vulnerability report](https://dannyodler.medium.com/attacking-the-golden-ring-on-amd-mini-pc-b7bfb217b437) and establish persistence by updating contents of the SPI flash (BIOS).

## Proof of Concept (PoC)

The attached demo project demonstrates successful exploitation and dumps contents of MSRs that are only accessible in SMM as well as a physical address of EPTP, which would be used to break HVCI if enabled.

The PoC is tested on Windows build 18362.1256, with and without HVCI enabled.

Recoding of successful exploitation can be found as [an unlisted YouTube video](https://youtu.be/1H3AfaVyeuk).

### Test Instructions

1. Open the demo.sln in Visual Studio 2019
2. Build the solution for Debug or Release build
3. Copy the compiled demo.sys into the target system (say, C:\users\user\desktop\demo.sys)

On the target system,
1. Disable secure boot from BIOS, and reboot
2. Enable the test signing mode, and reboot
    ```
    > bcdedit /set testsigning on
    ```
3. Create the service to load the demo.sys
    ```
    > sc create demo type= kernel binPath= C:\users\user\desktop\demo.sys
    ```
4. Start [DebugView](https://docs.microsoft.com/en-us/sysinternals/downloads/debugview) and enable "Capture Kernel" from the "Capture" menu.
5. Start the demo
    ```
    > sc start demo
    ```
6. If successful, DebugView will show output like this.
    ```
    [+] FindSystemManagementServiceTable: SMM core found at 0x87f1b390 in RT Code
    [+] FindSystemManagementServiceTable: SMST found at 0x887fa710 in SMRAM
    [+] ExploitSmm: Patched SMST->SmmLocateProtocol in SMRAM
    [+] ExploitSmm: Placed SMM shell code
    [+] ExploitSmm: Triggered SMM exploit
    [+] DumpSmmExploitOuput: IA32_SMBASE             = 0x887cd000
    [+] DumpSmmExploitOuput: MSR_SMM_FEATURE_CONTROL = 0x1
    [+] DumpSmmExploitOuput: MSR_SMM_MCA_CAP         = 0xc00000000000000
    [+] DumpSmmExploitOuput: EPT pointer             = 0x10a72001e
    [+] ExploitSmm: Successfully executed shell code in SMM. Failing DriverEntry to unload itself
    DriverEntry failed 0xc0000120 for driver \REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\demo
    ```
